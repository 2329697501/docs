Использование внедрения зависимостей
************************************

Следующий пример немного длинный, но объясняет использование сервис-локации и внедрение зависимостей.
Итак, представим, что мы разрабатываем компонент, назовём его SomeComponent. Сейчас нам не важно, какую именно задачу он выполняет.
Наш компонент имеет некоторую зависимость, отвечающую за соединение с базой данных.

В первом примере соединение устанавливается внутри компонента. Такой подход не является практичным, так как
не позволяет нам менять параметры соединения или тип СУБД из-за того, что компонент работает только так, как был создан.

.. code-block:: php

    <?php

    class SomeComponent
    {
        /**
         * Создание соединения жестко вшито в
         * компонент, поэтому сложно его заменить
         * или изменить его поведение
         */
        public function someDbTask()
        {
            $connection = new Connection(
                array(
                    "host"     => "localhost",
                    "username" => "root",
                    "password" => "secret",
                    "dbname"   => "invo"
                )
            );

            // ...
        }
    }

    $some = new SomeComponent();
    $some->someDbTask();

Чтобы решить эту проблему, создадим сеттер (setter), который внедрит внешнюю зависимость перед использованием. Теперь это похоже на
хорошее решение:

.. code-block:: php

    <?php

    class SomeComponent
    {
        protected $_connection;

        /**
         * Назначает внешнее соединение
         */
        public function setConnection($connection)
        {
            $this->_connection = $connection;
        }

        public function someDbTask()
        {
            $connection = $this->_connection;

            // ...
        }
    }

    $some = new SomeComponent();

    // Создаем соединение с БД
    $connection = new Connection(
        array(
            "host"     => "localhost",
            "username" => "root",
            "password" => "secret",
            "dbname"   => "invo"
        )
    );

    // Внедряем соединение в компонент
    $some->setConnection($connection);

    $some->someDbTask();

Теперь примем во внимание тот факт, что мы используем компонент в различных частях приложения,
поэтому появляется необходимость создавать соединение несколько раз и передавать его в компонент.
С помощью некоторого глобального реестра будем получать копию соединения, тем самым нам больше нет надобности
создавать его вновь и вновь:

.. code-block:: php

    <?php

    class Registry
    {
        /**
         * Возвращает соединение
         */
        public static function getConnection()
        {
            return new Connection(
                array(
                    "host"     => "localhost",
                    "username" => "root",
                    "password" => "secret",
                    "dbname"   => "invo"
                )
            );
        }
    }

    class SomeComponent
    {
        protected $_connection;

        /**
         * Назначает внешнее соединение
         */
        public function setConnection($connection)
        {
            $this->_connection = $connection;
        }

        public function someDbTask()
        {
            $connection = $this->_connection;

            // ...
        }
    }

    $some = new SomeComponent();

    // Передаем соединение, определенное в реестре
    $some->setConnection(Registry::getConnection());

    $some->someDbTask();

Теперь представим, что нам необходимо реализовать в компоненте два метода: первый всегда нуждается в создании нового соединения, а второй всегда использует уже установленное (shared):

.. code-block:: php

    <?php

    class Registry
    {
        protected static $_connection;

        /**
         * Создаёт соединение
         */
        protected static function _createConnection()
        {
            return new Connection(
                array(
                    "host"     => "localhost",
                    "username" => "root",
                    "password" => "secret",
                    "dbname"   => "invo"
                )
            );
        }

        /**
         * Создаёт соединение единожды и возвращает его
         */
        public static function getSharedConnection()
        {
            if (self::$_connection===null) {
                $connection = self::_createConnection();
                self::$_connection = $connection;
            }

            return self::$_connection;
        }

        /**
         * Всегда возвращает новое соединение
         */
        public static function getNewConnection()
        {
            return self::_createConnection();
        }
    }

    class SomeComponent
    {
        protected $_connection;

        /**
         * Назначает внешнее соединение
         */
        public function setConnection($connection)
        {
            $this->_connection = $connection;
        }

        /**
         * Для этого метода всегда требуется уже установленное соединение
         */
        public function someDbTask()
        {
            $connection = $this->_connection;

            // ...
        }

        /**
         * Для этого метода всегда требуется новое соединение
         */
        public function someOtherDbTask($connection)
        {

        }
    }

    $some = new SomeComponent();

    // Тут внедряется уже установленное (shared) соединение
    $some->setConnection(Registry::getSharedConnection());

    $some->someDbTask();

    // А здесь всегда в качестве параметра передаётся новое соединение
    $some->someOtherDbTask(Registry::getNewConnection());

До сих пор мы рассматривали случаи, когда внедрение зависимостей решает наши задачи. Передача зависимостей в качестве аргументов вместо
создания их внутри кода делает наше приложение более гибким и уменьшает его связанность. Однако, в перспективе,
такая форма внедрения зависимостей имеет некоторые недостатки.

Например, если компонент имеет много зависимостей, мы будем вынуждены создавать сеттеры с множеством аргументов для передачи
зависимостей или конструктор, который принимает их в качестве большого числа аргументов, вдобавок к этому, всякий раз создавать ещё и сами зависимости
до использования компонента. Это сделает наш код слишком сложным для сопровождения:

.. code-block:: php

    <?php

    // Создаем зависимости или получаем их из реестра
    $connection = new Connection();
    $session    = new Session();
    $fileSystem = new FileSystem();
    $filter     = new Filter();
    $selector   = new Selector();

    // Передаем их в конструктор в качестве параметров
    $some = new SomeComponent($connection, $session, $fileSystem, $filter, $selector);

    // ... Или используем сеттеры

    $some->setConnection($connection);
    $some->setSession($session);
    $some->setFileSystem($fileSystem);
    $some->setFilter($filter);
    $some->setSelector($selector);

Представьте, что пришлось бы создавать этот объект во многих частях нашего приложения. Если когда-нибудь мы перестанем нуждаться в какой-либо зависимости,
нам придётся пройтись по всем этим местам и удалить соответствующий параметр в вызовах конструктора или в сеттерах. Чтобы решить эту проблему,
вернёмся к глобальному реестру для создания компонента. Однако, это добавит новый уровень абстракции, предшествующий созданию
объекта:

.. code-block:: php

    <?php

    class SomeComponent
    {
        // ...

        /**
         * Определение метода factory, который создаёт экземпляр SomeComponent и внедряет в него зависимости
         */
        public static function factory()
        {
            $connection = new Connection();
            $session    = new Session();
            $fileSystem = new FileSystem();
            $filter     = new Filter();
            $selector   = new Selector();

            return new self($connection, $session, $fileSystem, $filter, $selector);
        }
    }

Минуточку, мы снова вернулись туда, откуда начали: создание зависимостей внутри компонента! Мы можем двигаться дальше и находить способ
решать эту проблему каждый раз. Но, это означает, что мы снова и снова будем наступать на те же грабли.

Практически применимый и элегантный способ решить эту проблему — это использовать контейнер для зависимостей. Он играет ту же роль, что и глобальный реестр, который
мы видели выше. Использование контейнера в качестве моста к зависимостям позволяет нам уменьшить сложность
нашего компонента:

.. code-block:: php

    <?php

    use Phalcon\Di;

    class SomeComponent
    {
        protected $_di;

        public function __construct($di)
        {
            $this->_di = $di;
        }

        public function someDbTask()
        {
            // Получение сервиса соединений
            // Всегда возвращает соединение
            $connection = $this->_di->get('db');
        }

        public function someOtherDbTask()
        {
            // Получение сервиса соединения, предназначенного для общего доступа,
            // всегда возвращает одно и то же соединение
            $connection = $this->_di->getShared('db');

            // Этот метод так же требует сервис фильтрации входных данных
            $filter = $this->_di->get('filter');
        }
    }

    $di = new Di();

    // Регистрируем в контейнере сервис "db"
    $di->set('db', function () {
        return new Connection(
            array(
                "host"     => "localhost",
                "username" => "root",
                "password" => "secret",
                "dbname"   => "invo"
            )
        );
    });

    // Регистрируем в контейнере сервис "filter"
    $di->set('filter', function () {
        return new Filter();
    });

    // Регистрируем в контейнере сервис "session"
    $di->set('session', function () {
        return new Session();
    });

    // Передаем контейнер сервисов в качестве единственного параметра
    $some = new SomeComponent($di);

    $some->someDbTask();

Теперь компонент имеет простой доступ к сервисам, которые ему необходимы. Если сервис невостребован, он не будет инициализирован,
тем самым экономя ресурсы. Также компонент теперь обладает низкой связанностью. Например, можно заменить способ создания соединений,
поведение или любой другой аспект их работы, и это никак не отразится на компоненте.

Наш подход
==========
:doc:`Phalcon\\Di <../api/Phalcon_Di>` — это компонент, реализующий внедрение зависимостей и локацию сервисов, и он же является контейнером для них.

Поскольку Phalcon обладает низкой связанностью, :doc:`Phalcon\\Di <../api/Phalcon_Di>` необходимо обеспечить интеграцию различных компонентов фреймворка. Разработчики также могут
использовать этот компонент для внедрения зависимостей и использования глобальных экземпляров различных классов, используемых в приложении.

В основе своей, компонент реализует паттерн `Инверсии управления`_. Применяя его, объекты получают их зависимости не с
использованием сеттеров или конструкторов, а с помощью сервиса внедрения зависимостей. Это снижает общую сложность, поскольку остаётся только
один способ получения зависимостей в компоненте.

К тому же, этот паттерн увеличивает тестируемость в коде, что позволяет снизить "ошибочность" кода.

Регистрация сервисов в контейнере сервисов
==========================================
Регистрация сервисов возможна как разработчиком, так и самим фреймворком. Когда компоненту A требуется компонент B (или экземпляр его класса) для работы, он
может запросить его из контейнера, а не создавать новый экземпляр.

Такой способ работы даёт нам много преимуществ:

* Мы можем легко заменять компонент на созданный нами или кем-то другим.
* Мы обладаем полным контролем над инициализацией объекта, что позволяет нам настраивать эти объекты так, как нам необходимо, прежде, чем передать их компонентам.
* Мы можем получать глобальный экземпляр компонента структурированным и унифицированным образом.

Зарегистрировать сервисы можно несколькими различными способами:

.. code-block:: php

    <?php

    use Phalcon\Http\Request;

    // Создем контейнер DI
    $di = new Phalcon\Di();

    // По названию класса
    $di->set("request", 'Phalcon\Http\Request');

    // С использованием анонимной функции для отложенной загрузки
    $di->set("request", function () {
        return new Request();
    });

    // Регистрация экземпляра напрямую
    $di->set("request", new Request());

    // Определение с помощью массива
    $di->set(
        "request",
        array(
            "className" => 'Phalcon\Http\Request'
        )
    );

Для регистрации сервисов можно также использовать синтаксис массивов:

.. code-block:: php

    <?php

    use Phalcon\Http\Request;

    // Создем контейнер DI
    $di = new Phalcon\Di();

    // По названию класса
    $di["request"] = 'Phalcon\Http\Request';

    // С использованием анонимной функции для отложенной загрузки
    $di["request"] = function () {
        return new Request();
    };

    // Регистрация экземпляра напрямую
    $di["request"] = new Request();

    // Определение с помощью массива
    $di["request"] = array(
        "className" => 'Phalcon\Http\Request'
    );

В примере, данном выше, когда фреймворк нуждается в доступе к запрашиваемым данным, он будет запрашивать в контейнере сервис, названный 'request'.
Контейнер, в свою очередь, возвращает экземпляр требуемого сервиса. Разработчик, в конечном итоге, может заменить компонент, когда захочет.

Каждый из методов регистрации сервисов имеет свои достоинства и недостатки.
Какой из них использовать — зависит только от разработчика и от конкретных требований.

Назначить сервис строкой просто, но это лишает гибкости. В качестве массива — предоставляет большую гибкость, но делает
код более сложным. Анонимные функции неплохо балансируют между этими двумя способами, но им может потребоваться больше обслуживания, чем это ожидается.

:doc:`Phalcon\\Di <../api/Phalcon_Di>` предоставляет отложенную загрузку для каждого хранимого им сервиса. Если разработчик не решит создавать экземпляр объекта напрямую и хранить его
в контейнере, любой объект сохранённый в нём (через массив, строку и т.д.) будет загружен отложенно (lazy load), т.е. создастся только тогда, когда будет востребован.

Простая регистрация
-------------------
Как было показано выше, есть несколько способов регистрации сервисов. Следующие из них мы называем "простыми":

Строка
^^^^^^
Этот способ ожидает в качестве параметра имя существующего класса, возвращает его объект, если класс не был загружен автозагрузчиком.
Такой способ не позволяет передавать аргументы для конструктора класса или настраивать параметры:

.. code-block:: php

    <?php

    // Возвращает новый Phalcon\Http\Request();
    $di->set('request', 'Phalcon\Http\Request');

Объект
^^^^^^
Этот способ в качестве параметра принимает объект. Объект не нуждается в создании, потому как объект
уже является объектом сам по себе. Вообще говоря, в данном случае это не является настоящим внедрением зависимости,
однако такой способ вполне используем, если вы хотите быть уверены в том, что возвращаемая зависимость всегда будет
одним и тем же объектом/значением:

.. code-block:: php

    <?php

    use Phalcon\Http\Request;

    // Возвращает новый Phalcon\Http\Request();
    $di->set('request', new Request());

Замыкания/Анонимные функции
^^^^^^^^^^^^^^^^^^^^^^^^^^^
Этот метод дает больше свободы для построения зависимости, если этого захотеть, тем не менее, он весьма сложен в плане
изменения некоторых параметров извне без полного замещения определения зависимости:

.. code-block:: php

    <?php

    use Phalcon\Db\Adapter\Pdo\Mysql as PdoMysql;

    $di->set("db", function () {
        return new PdoMysql(
            array(
                "host"     => "localhost",
                "username" => "root",
                "password" => "secret",
                "dbname"   => "blog"
            )
        );
    });

Некоторые ограничения можно преодолеть путём передачи дополнительных переменных в область видимости замыкания:

.. code-block:: php

    <?php

    use Phalcon\Db\Adapter\Pdo\Mysql as PdoMysql;

    // Использование переменной $config в текущей области видимости
    $di->set("db", function () use ($config) {
        return new PdoMysql(
            array(
                "host"     => $config->host,
                "username" => $config->username,
                "password" => $config->password,
                "dbname"   => $config->name
            )
        );
    });

Сложная регистрация
-------------------
Если потребуется изменить определение сервиса без создания экземпляра,
тогда нам придётся определять его с использованием синтаксиса массивов. Такое определение
может оказаться чуть более длинным:

.. code-block:: php

    <?php

    use Phalcon\Logger\Adapter\File as LoggerFile;

    // Регистрируем сервис 'logger' с помощью имени класса и его параметров
    $di->set('logger', array(
        'className' => 'Phalcon\Logger\Adapter\File',
        'arguments' => array(
            array(
                'type'  => 'parameter',
                'value' => '../apps/logs/error.log'
            )
        )
    ));

    // Или в виде анонимной функции
    $di->set('logger', function () {
        return new LoggerFile('../apps/logs/error.log');
    });

Оба способа приведут к одинаковому результату. Определение же с помощью массива позволяет изменять параметры, если это необходимо:

.. code-block:: php

    <?php

    // Изменяем названия класса для сервиса
    $di->getService('logger')->setClassName('MyCustomLogger');

    // Изменяем первый параметр без пересоздания экземпляра сервиса logger
    $di->getService('logger')->setParameter(0, array(
        'type'  => 'parameter',
        'value' => '../apps/logs/error.log'
    ));

В дополнение к этому, используя синтаксис массивов, можно использовать три типа внедрения зависимостей:

Внедрение с помощью конструктора
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Этот тип передаёт зависимости/аргументы в конструктор класса.
Представим, что у нас есть следующий компонент:

.. code-block:: php

    <?php

    namespace SomeApp;

    use Phalcon\Http\Response;

    class SomeComponent
    {
        protected $_response;

        protected $_someFlag;

        public function __construct(Response $response, $someFlag)
        {
            $this->_response = $response;
            $this->_someFlag = $someFlag;
        }
    }

Сервис может быть зарегистрирован следующим образом:

.. code-block:: php

    <?php

    $di->set('response', array(
        'className' => 'Phalcon\Http\Response'
    ));

    $di->set('someComponent', array(
        'className' => 'SomeApp\SomeComponent',
        'arguments' => array(
            array('type' => 'service', 'name' => 'response'),
            array('type' => 'parameter', 'value' => true)
        )
    ));

Сервис "response" (:doc:`Phalcon\\Http\\Response <../api/Phalcon_Http_Response>`) передаётся в конструктор в качестве первого параметра,
в то время как вторым параметром передаётся булевое значение (true) без изменений.

Внедрение с помощью сеттера
^^^^^^^^^^^^^^^^^^^^^^^^^^^
Классы могут иметь сеттеры для внедрения дополнительных зависимостей. Наш предыдущий класс может быть изменён, чтобы принимать зависимости с помощью сеттеров:

.. code-block:: php

    <?php

    namespace SomeApp;

    use Phalcon\Http\Response;

    class SomeComponent
    {
        protected $_response;

        protected $_someFlag;

        public function setResponse(Response $response)
        {
            $this->_response = $response;
        }

        public function setFlag($someFlag)
        {
            $this->_someFlag = $someFlag;
        }
    }

Сервис с сеттерами для зависимостей может быть зарегистрирован следующим образом:

.. code-block:: php

    <?php

    $di->set('response', array(
        'className' => 'Phalcon\Http\Response'
    ));

    $di->set(
        'someComponent',
        array(
            'className' => 'SomeApp\SomeComponent',
            'calls'     => array(
                array(
                    'method'    => 'setResponse',
                    'arguments' => array(
                        array(
                            'type' => 'service',
                            'name' => 'response'
                        )
                    )
                ),
                array(
                    'method'    => 'setFlag',
                    'arguments' => array(
                        array(
                            'type'  => 'parameter',
                            'value' => true
                        )
                    )
                )
            )
        )
    );

Внедерение через свойства класса
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Менее распространённым способом является внедрение зависимостей или полей класса напрямую:

.. code-block:: php

    <?php

    namespace SomeApp;

    use Phalcon\Http\Response;

    class SomeComponent
    {
        public $response;

        public $someFlag;
    }

Сервис с прямым внедрением может быть зарегистрирован следующим способом:

.. code-block:: php

    <?php

    $di->set(
        'response',
        array(
            'className' => 'Phalcon\Http\Response'
        )
    );

    $di->set(
        'someComponent',
        array(
            'className'  => 'SomeApp\SomeComponent',
            'properties' => array(
                array(
                    'name'  => 'response',
                    'value' => array(
                        'type' => 'service',
                        'name' => 'response'
                    )
                ),
                array(
                    'name'  => 'someFlag',
                    'value' => array(
                        'type'  => 'parameter',
                        'value' => true
                    )
                )
            )
        )
    );

Поддерживаются параметры следующих типов:

+-------------+----------------------------------------------------------+---------------------------------------------------------------------------------------------+
| Тип         | Описание                                                 | Пример                                                                                      |
+=============+==========================================================+=============================================================================================+
| parameter   | Буквенное значение, передаваемое в качестве параметра    | :code:`array('type' => 'parameter', 'value' => 1234)`                                       |
+-------------+----------------------------------------------------------+---------------------------------------------------------------------------------------------+
| service     | Другой сервис в контейнере                               | :code:`array('type' => 'service', 'name' => 'request')`                                     |
+-------------+----------------------------------------------------------+---------------------------------------------------------------------------------------------+
| instance    | Объект, который должен создаваться динамически           | :code:`array('type' => 'instance', 'className' => 'DateTime', 'arguments' => array('now'))` |
+-------------+----------------------------------------------------------+---------------------------------------------------------------------------------------------+

Получение сервисов, определение которых весьма сложно может быть немного медленнее, чем рассмотренные выше определения. Однако,
это предоставляет больше возможностей для определения и внедрения сервисов.

Можно совмещать различные типы определения, определяя для себя наиболее подходящий способ регистрации сервиса
в соответствии с потребностями приложения.

Доступ к сервисам
=================
Получение сервиса из контейнера очень просто производится вызовом метода "get". Будет возвращен новый экземпляр сервиса:

.. code-block:: php

    <?php $request = $di->get("request");

Также можно вызвать магический метод:

.. code-block:: php

    <?php

    $request = $di->getRequest();

Или использовать доступ как к массиву:

.. code-block:: php

    <?php

    $request = $di['request'];

Аргументы могут быть переданы в конструктор добавлением массива параметров в метод "get":

.. code-block:: php

    <?php

    // новый MyComponent("some-parameter", "other")
    $component = $di->get("MyComponent", array("some-parameter", "other"));

События
-------
:doc:`Phalcon\\Di <../api/Phalcon_Di>` может посылать события в :doc:`EventsManager <events>`, если таковой имеется.
События вызываются с типом "di". Некоторые события, при возвращении значения false, могут прервать текущее действие.
Поддерживаются следующие события:

+----------------------+---------------------------------------------------------------------------------------------------------------------------------+-----------------------------+--------------------+
| Название события     | Когда вызывается                                                                                                                | Можно ли прервать действие? | Срабатывает на     |
+======================+=================================================================================================================================+=============================+====================+
| beforeServiceResolve | Вызывается до разрешения сервиса (service resolve). Слушатели (listeners) получают название сервиса и переданные ему параметры. | Нет                         | Слушателях         |
+----------------------+---------------------------------------------------------------------------------------------------------------------------------+-----------------------------+--------------------+
| afterServiceResolve  | Вызывается после разрешения сервиса. Слушатели получают название сервиса, экземпляр и переданные ему параметры.                 | Нет                         | Слушателях         |
+----------------------+---------------------------------------------------------------------------------------------------------------------------------+-----------------------------+--------------------+

Совместный доступ к сервисам
============================
Сервисы могут быть зарегистрированы, как предназначенные для совместного ("shared") доступа. Это означает, что они всегда будут `синглтонами`_. После того, как этот сервис будет один раз создан,
всегда будет возвращаться тот же самый его экземпляр:

.. code-block:: php

    <?php

    use Phalcon\Session\Adapter\Files as SessionFiles;

    // Регистрируем сервис сессий для совместного доступа
    $di->setShared('session', function () {
        $session = new SessionFiles();
        $session->start();
        return $session;
    });

    $session = $di->get('session'); // Создает сервис в первый раз
    $session = $di->getSession();   // Возвращает первоначальный экзмепляр объекта

Также можно зарегистрировать сервис с совместным доступом, передав "true" в качестве третьего параметра метода "set":

.. code-block:: php

    <?php

    // Регистрация сервиса сессий для совместного доступа
    $di->set('session', function () {
        // ...
    }, true);

Если сервис не был зарегистрирован для общего доступа, и вы хотите всё же получать один и тот же экземпляр каждый раз,
то можно получать его, используя метод DI "getShared":

.. code-block:: php

    <?php

    $request = $di->getShared("request");

Ручное управление сервисами
===========================
После того, как сервис был зарегистрирован в контейнере, вы можете управлять им вручную:

.. code-block:: php

    <?php

    use Phalcon\Http\Request;

    // Регистрируем сервис "request"
    $di->set('request', 'Phalcon\Http\Request');

    // Получем сервис
    $requestService = $di->getService('request');

    // Изменяем его определение
    $requestService->setDefinition(function () {
        return new Request();
    });

    // Делаем его общим
    $requestService->setShared(true);

    // Разрешаем сервис (возвращает экземпляр Phalcon\Http\Request)
    $request = $requestService->resolve();

Создание экземпляров классов через контейнер сервисов
=====================================================
Когда вы запрашиваете какой-то сервис из контейнера, и он не может найти его по такому имени, контейнер пытается загрузить класс с таким
же названием. С помощью этого вы можете легко заменить какой-либо класс на любой другой, зарегистрировав сервис с таким же названием:

.. code-block:: php

    <?php

    // Регистрируем контроллер как сервис
    $di->set('IndexController', function () {
        $component = new Component();
        return $component;
    }, true);

    // Регистрируем компонент как сервис
    $di->set('MyOtherComponent', function () {
        // Actually returns another component
        $component = new AnotherComponent();
        return $component;
    });

    // Создаем экземпляр объекта с помощью контейнера сервисов
    $myComponent = $di->get('MyOtherComponent');

Вы можете пользоваться этим, всегда создавая экземпляры объектов ваших классов с помощью контейнера сервисов (даже если они не регистрировались как сервисы). DI будет
запускать правильный автозагрузчик для того, чтобы в итоге загрузить класс. Делая так, вы сможете легко заменить любой класс в будущем, реализовав
его определение.

Автоматическое внедрение DI
===========================
Если класс или компонент требует DI для нахождения сервисов, DI может автоматически внедрить себя в экземпляры этих компонентов или объектов,
чтобы сделать это вам необходимо реализовать :doc:`Phalcon\\Di\\InjectionAwareInterface <../api/Phalcon_Di_InjectionAwareInterface>` в своём классе:

.. code-block:: php

    <?php

    use Phalcon\Di\InjectionAwareInterface;

    class MyClass implements InjectionAwareInterface
    {
        protected $_di;

        public function setDi($di)
        {
            $this->_di = $di;
        }

        public function getDi()
        {
            return $this->_di;
        }
    }

Когда сервис будет запрошен, :code:`$di` будет передан в :code:`setDi()` автоматически:

.. code-block:: php

    <?php

    // Регистрируем сервис
    $di->set('myClass', 'MyClass');

    // Получаем сервис (ВНИМАНИЕ: $myClass->setDi($di) вызовется автоматически)
    $myClass = $di->get('myClass');

Избежание разрешения сервисов
=============================
Сервисы, которые используются при каждом обращении к приложению, могут избежать процесса их разрешения,
что может немного увеличить производительность:

.. code-block:: php

    <?php

    // Внешнее разрешение объекта вместо его определения
    $router = new MyRouter();

    // Передаем уже созданный объект
    $di->set('router', $router);

Размещение сервисов в файлах
============================
Вы можете улучшить организацию вашего приложения переместив регистрацию сервисов в отдельные файлы, которые
делают всё, что происходит при старте приложения:

.. code-block:: php

    <?php

    $di->set('router', function () {
        return include "../app/config/routes.php";
    });

А файл ("../app/config/routes.php") вернёт готовый объект:

.. code-block:: php

    <?php

    $router = new MyRouter();

    $router->post('/login');

    return $router;

Статический доступ к DI
=======================
При необходимости вы можете получить доступ к последнему созданному DI в статической функции следующим образом:

.. code-block:: php

    <?php

    use Phalcon\Di;

    class SomeComponent
    {
        public static function someMethod()
        {
            // Получаем сервис сессий
            $session = Di::getDefault()->getSession();
        }
    }

Factory Default DI
==================
Несмотря на то, что разрозненный характер Phalcon дарит нам огромную свободу и гибкость, возможно мы захотим легко использовать полноценный
фреймворк. Для достижения этой цели фреймворк предоставляет вариант :doc:`Phalcon\\Di <../api/Phalcon_Di>`, называющийся :doc:`Phalcon\\Di\\FactoryDefault <../api/Phalcon_Di_FactoryDefault>`. Этот класс автоматически
регистрирует такие сервисы, которые обычно определены в полноценном фреймворке.

.. code-block:: php

    <?php

    use Phalcon\Di\FactoryDefault;

    $di = new FactoryDefault();

Соглашение именования сервисов
==============================
Хотя, вы и можете регистрировать сервисы с любыми именами, какие вам только понравятся, Phalcon имеет некоторое соглашение именования сервисов, что позволяет ему
правильно работать с сервисами, когда они вам необходимы.

+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| Название сервиса    | Описание                                    | По умолчанию                                                                                       | Общий доступ |
+=====================+=============================================+====================================================================================================+==============+
| dispatcher          | Диспетчер контроллеров                      | :doc:`Phalcon\\Mvc\\Dispatcher <../api/Phalcon_Mvc_Dispatcher>`                                    | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| router              | Маршрутизатор                               | :doc:`Phalcon\\Mvc\\Router <../api/Phalcon_Mvc_Router>`                                            | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| url                 | Генератор URL'ов                            | :doc:`Phalcon\\Mvc\\Url <../api/Phalcon_Mvc_Url>`                                                  | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| request             | Окружение HTTP запросов                     | :doc:`Phalcon\\Http\\Request <../api/Phalcon_Http_Request>`                                        | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| response            | Окружение HTTP ответов                      | :doc:`Phalcon\\Http\\Response <../api/Phalcon_Http_Response>`                                      | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| cookies             | Сервис управления HTTP Cookies              | :doc:`Phalcon\\Http\\Response\\Cookies <../api/Phalcon_Http_Response_Cookies>`                     | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| filter              | Входной фильтр                              | :doc:`Phalcon\\Filter <../api/Phalcon_Filter>`                                                     | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| flash               | Всплывающие сообщения                       | :doc:`Phalcon\\Flash\\Direct <../api/Phalcon_Flash_Direct>`                                        | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| flashSession        | Сессия всплывающих сообщений                | :doc:`Phalcon\\Flash\\Session <../api/Phalcon_Flash_Session>`                                      | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| session             | Сессия                                      | :doc:`Phalcon\\Session\\Adapter\\Files <../api/Phalcon_Session_Adapter_Files>`                     | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| eventsManager       | Управление событиями                        | :doc:`Phalcon\\Events\\Manager <../api/Phalcon_Events_Manager>`                                    | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| db                  | Низкоуровневый коннектор к базе данных      | :doc:`Phalcon\\Db <../api/Phalcon_Db>`                                                             | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| security            | Помощник безопасности                       | :doc:`Phalcon\\Security <../api/Phalcon_Security>`                                                 | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| crypt               | Шифрование/Дешифрование данных              | :doc:`Phalcon\\Crypt <../api/Phalcon_Crypt>`                                                       | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| tag                 | генератор HTML конструкций                  | :doc:`Phalcon\\Tag <../api/Phalcon_Tag>`                                                           | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| escaper             | Контекстное экранирование                   | :doc:`Phalcon\\Escaper <../api/Phalcon_Escaper>`                                                   | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| annotations         | Парсер аннотаций                            | :doc:`Phalcon\\Annotations\\Adapter\\Memory <../api/Phalcon_Annotations_Adapter_Memory>`           | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| modelsManager       | Управление моделями                         | :doc:`Phalcon\\Mvc\\Model\\Manager <../api/Phalcon_Mvc_Model_Manager>`                             | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| modelsMetadata      | Мета-данные моделей                         | :doc:`Phalcon\\Mvc\\Model\\MetaData\\Memory <../api/Phalcon_Mvc_Model_MetaData_Memory>`            | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| transactionManager  | Управление транзакциями моделей             | :doc:`Phalcon\\Mvc\\Model\\Transaction\\Manager <../api/Phalcon_Mvc_Model_Transaction_Manager>`    | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| modelsCache         | Кэширование для моделей                     | Нет                                                                                                | Нет          |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| viewsCache          | Кэширование для частичных представлений     | Нет                                                                                                | Нет          |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+

Реализация собственного DI
==========================
Для создания собственного DI необходимо реализовать интерфейс :doc:`Phalcon\\DiInterface <../api/Phalcon_DiInterface>`, или использовать наследование и переопределить стандартный компонент Phalcon.

.. _`Инверсии управления`: http://ru.wikipedia.org/wiki/Инверсия_управления
.. _синглтонами: http://ru.wikipedia.org/wiki/Одиночка_(шаблон_проектирования)
