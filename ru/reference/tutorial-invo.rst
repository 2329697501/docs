Урок 2: Введение в INVO
=======================

Во втором уроке мы создадим более сложное приложение с помощью Phalcon. INVO это одно из приложений, которое мы создали в качестве примера. INVO это небольшой сайт, который позволяет своим пользователям создавать счета и выполнять другие задачи для управления своими клиентами и продуктами. Полный код проекта можно клонировать из Github_.

INVO использует `Bootstrap`_ в качестве фронтенд-фреймворка. Кроме того, приложение не будет генерировать счета, оно служит для понимая того, как работает фреймворк.

Структура проекта
-----------------
После того как вы склонируете проект в корневой каталог вы увидите следующую структуру:

.. code-block:: bash

    invo/
        app/
            config/
            controllers/
            library/
            forms/
            models/
            plugins/
            views/
        public/
            bootstrap/
            css/
            js/
        schemas/

Как вы уже знаете, Phalcon не навязывает определенную структуру файлов и каталогов для разработки приложений. Этот проект обеспечивает простую стуктуру MVC и корневой каталог public.

После того, как вы откроете приложение в браузере http://localhost/invo вы увидите что-то вроде этого:

.. figure:: ../_static/img/invo-1.png
   :align: center

Приложение состоит из двух частей, фронтенд - внешняя часть, где поситители могут получить информацию о INVO и запросить контактные данные. И бэкенд - административную панель, где зарегистрированный пользователь может управлять своими продуктами и клиентами.

Маршрутизация
-------------
INVO использует стандартный маршрутизатор основанный на встроенном компоненте Route. Эти маршруты соответствуют следующим шаблонам: /:controller/:action/:params. Первая часть URI является контроллером, вторая имя действия и остальные параметры.

Маршрут /session/register выполняет контроллер SessionController и его действие registerAction.

Конфигурация
------------
INVO имеет конфигурационный файл, который устанавливает общие параметры приложения. Этот файл загружается в самом начале
загрузочного файла (public/index.php):

.. code-block:: php

    <?php

    use Phalcon\Config\Adapter\Ini as ConfigIni;

    // ...

    // Читаем конфигурацию
    $config = new ConfigIni(APP_PATH . 'app/config/config.ini');

:doc:`Phalcon\\Config <config>` позволяет нам манипулировать файлами в объектно-ориентированном стиле. Файл конфигурации
содержит следующие настройки:

.. code-block:: ini

    [database]
    host     = localhost
    username = root
    password = secret
    name     = invo

    [application]
    controllersDir = app/controllers/
    modelsDir      = app/models/
    viewsDir       = app/views/
    pluginsDir     = app/plugins/
    formsDir       = app/forms/
    libraryDir     = app/library/
    baseUri        = /invo/

Phalcon не имеет каких-либо предопределенных соглашений о конфигурациях. Разделы помогут нам организовать необходимые параметры. В этом файле три секции, которые мы будем использовать позже.

Автозагрузчики
--------------
Второе, что видно в в загрузочном файле (public/index.php) это автозагрузчик.

.. code-block:: php

    <?php

    /**
     * Конфигурация автозагрузчика
     */
    require APP_PATH . 'app/config/loader.php';

Автозагрузчик регистрирует набор каталогов, где приложение будет искать необходимые классы.

.. code-block:: php

    <?php

    $loader = new Phalcon\Loader();

    // Регистрируем набор каталогов, полученных из конфигурационного файла
    $loader->registerDirs(
        array(
            APP_PATH . $config->application->controllersDir,
            APP_PATH . $config->application->pluginsDir,
            APP_PATH . $config->application->libraryDir,
            APP_PATH . $config->application->modelsDir,
            APP_PATH . $config->application->formsDir,
        )
    )->register();

Обратите внимание на регистрацию каталогов в файле конфигураций.
Единтсвенная директория которая не была зарегистрирована с помощью автозагрузчика это viewsDir, потому что она не содержит классов, только HTML + PHP файлы.
Также заметьте, что мы используем константу APP_PATH, эта константа определена в загрузочном файле
(public/index.php), чтобы позволить нам ссылаться на корень нашего проекта:

.. code-block:: php

    <?php

    // ...

    define('APP_PATH', realpath('..') . '/');

Регистрация сервисов
--------------------
Другой файл, необходимый для загрузочного, - это (app/config/services.php). Данный файл позволяет
нам организовать сервисы, которые используются в INVO.

.. code-block:: php

    <?php

    /**
     * Загружаем сервисы приложения
     */
    require APP_PATH . 'app/config/services.php';

Регистрация сервиса достигается, как и в предыдущем примере, используя замыкание для ленивой загрузки
требуемых компонентов:

.. code-block:: php

    <?php

    use Phalcon\Mvc\Url as UrlProvider;

    // ...

    /**
     * Компонент URL используется для генерации различных URL'ов в приложении
     */
    $di->set('url', function () use ($config) {
        $url = new UrlProvider();

        $url->setBaseUri($config->application->baseUri);

        return $url;
    });

Позже мы подробнее обсудим этот файл.

Обработка запроса
-----------------
Пойдем дальше, в конце файла, запрос окончательно обрабатывается с помощью :doc:`Phalcon\\Mvc\\Application <../api/Phalcon_Mvc_Application>`,
этот класс инициализирует и выполняет все что нужно для работы приложения:

.. code-block:: php

    <?php

    use Phalcon\Mvc\Application;

    // ...

    $app = new Application($di);

    echo $app->handle()->getContent();

Инъекция зависимостей
---------------------
Посмотрите на первую строку кода на предыдущем блоке, переменная :code:`$app` получает еще одну переменную :code:`$di` в своем конструкторе.
Каков смысл этой переменной? Phalcon - слабо связанный фреймворк, так что нам нужен компонент, который действует как клей, чтобы все работало вместе.
Этот компонент - :doc:`Phalcon\\Di <../api/Phalcon_DI>`. Это контейнер, обеспечивающий все связи между частями необходимыми в приложении.

Есть много способов регистрации сервисов в контейнере. В INVO большинство сервисов были зарегистрированы с использованием
анонимных функций. Благодаря этому, объекты создаются в ленивом стиле, снижая ресурсы, необходимые приложению.

Например, в следующем фрагменте регистрируется сервис сессии. Анонимная функция будет вызвана только тогда,
когда приложение требует доступа к данным сессии:

.. code-block:: php

    <?php

    use Phalcon\Session\Adapter\Files as Session;

    // ...

    // Начать сессию в первый раз, когда какой-либо компонент запросит сервис сессий.
    $di->set('session', function () {
        $session = new Session();

        $session->start();

        return $session;
    });

Здесь мы можем менять адаптер, выполнить дополнительную инициализацию и многое другое.
Обратите внимание, сервис был зарегистрирован с помощью имени  "session". Это соглашение позволит фреймворку идентифицировать активный метод в контейнере.

Запрос может использовать множество сервисов, а регистрация каждого из них может быть трудоемкой задачей. По этой причине,
фреймворк обеспечивает вариант :doc:`Phalcon\\Di <../api/Phalcon_DI>`, именуемый :doc:`Phalcon\\Di\\FactoryDefault <../api/Phalcon_DI_FactoryDefault>`, задачей которого является регистрация
всех сервисов, необходимых фреймворку.

.. code-block:: php

    <?php

    use Phalcon\Di\FactoryDefault;

    // ...

    // FactoryDefault обеспечивает автоматическую регистрацию
    // полного набора сервисов необходимых фреймворку
    $di = new FactoryDefault();

Он регистрирует большинство сервисов, предусмотренных фреймворком как стандартные. Если нам надо переопределить
какой-либо из сервисов, мы можем просто определить его снова, как мы делали выше с сервисом "session".
Это причина существования переменной :code:`$di`.

В следующей главе мы увидим, как в INVO реализованы аутентификация и авторизация.

.. _Github: https://github.com/phalcon/invo
.. _Bootstrap: http://getbootstrap.com/
